<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0066cc">
  <title>Skyboard Configuration</title>
  <link rel="stylesheet" href="/css/base.css">
  <link rel="stylesheet" href="/css/components.css">
  <script src="/js/components.js"></script>
</head>
<body>
  <header class="page-header">
    <h1>‚úàÔ∏è Skyboard Configuration</h1>
    <nav>
      <a href="/" class="active">Config</a>
      <a href="/diagnostics">Diagnostics</a>
    </nav>
  </header>

  <div class="container">
    <!-- Instructions -->
    <div class="card">
      <h2>Instructions</h2>
      <ul>
        <li><strong>Airport Codes:</strong> Type to search by ICAO code, airport name, or city</li>
        <li><strong>Legend Values:</strong> Use LIFR, IFR, MVFR, WVFR, or VFR for static color display</li>
        <li><strong>Skip LEDs:</strong> Enter "NULL" or "BLACK" to turn off</li>
        <li><strong>CSV Import:</strong> Upload a CSV file with format: index,code (e.g., "0,KSFO")</li>
        <li><strong>Changes save:</strong> Click "Save Configuration" when done</li>
      </ul>
    </div>

    <!-- Flight Category Legend -->
    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background: var(--color-lifr)"></div>
        <span>LIFR</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: var(--color-ifr)"></div>
        <span>IFR</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: var(--color-mvfr)"></div>
        <span>MVFR</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: var(--color-wvfr)"></div>
        <span>WVFR (Windy)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: var(--color-vfr)"></div>
        <span>VFR</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: var(--color-pending)"></div>
        <span>No Wx Data</span>
      </div>
    </div>

    <!-- Settings -->
    <div class="card">
      <h2>Settings</h2>
      <div class="settings-grid">
        <div class="setting-row">
          <label for="numLeds">Number of LEDs:</label>
          <input type="number" id="numLeds" class="input max-w-120" min="1" max="150" value="80">
        </div>
        <div class="setting-row">
          <label for="brightness">Brightness (0-255):</label>
          <div class="flex gap-md items-center flex-1">
            <input type="range" id="brightness" class="flex-1 max-w-300" min="0" max="255" value="20">
            <input type="number" id="brightnessValue" class="input w-80" min="0" max="255" value="20">
          </div>
        </div>
        <div class="setting-row">
          <label for="updateInterval">Update Interval:</label>
          <div class="flex gap-sm items-center">
            <input type="number" id="updateInterval" class="input w-80" min="5" max="60" value="15">
            <span>minutes</span>
          </div>
        </div>
        <div class="setting-row">
          <label for="hostname">Hostname:</label>
          <div class="flex flex-col gap-xs">
            <input type="text" id="hostname" class="input max-w-250" maxlength="32" placeholder="led-sectional" pattern="[a-zA-Z0-9\-]+">
            <small class="text-muted">
              Access via: http://<span id="hostnamePreview" class="font-bold">led-sectional</span>.local
            </small>
          </div>
        </div>
        <div class="setting-row">
          <label>Enable mDNS:</label>
          <div class="flex items-center">
            <input type="checkbox" id="useMDNS" checked>
          </div>
        </div>
      </div>
    </div>

    <!-- LED Assignments -->
    <div class="card">
      <div class="flex justify-between items-center mb-md">
        <h2 class="m-0">LED Assignments</h2>
        <button id="startWizardBtn" class="btn btn-primary">
          üîß Start LED Setup Wizard
        </button>
      </div>

      <!-- Setup Wizard Container (hidden by default) -->
      <div id="wizardContainer" class="wizard-container" style="display: none;">
        <div class="wizard-instructions">
          <p><strong>LED Setup Wizard</strong></p>
          <p>This wizard will help you identify each LED. The current LED will blink ORANGE. Previous LEDs will be GREEN. You can edit ANY textbox at ANY time. Click 'Next' to add the next LED.</p>
        </div>

        <div id="wizardRows" class="wizard-rows">
          <!-- Progressive LED rows will be added here by JavaScript -->
        </div>

        <div class="wizard-buttons">
          <button id="wizardSaveBtn" class="btn btn-success">
            üíæ Save Configuration
          </button>
        </div>
      </div>

      <!-- Manual LED Table (shown when wizard is not active) -->
      <div id="manualLedConfig">
        <div class="flex justify-between items-center mb-md gap-md">
          <input type="text" id="searchBox" class="input max-w-300" placeholder="Search by LED or airport code...">

          <!-- CSV Import Button -->
          <div class="flex gap-sm items-center">
            <input type="file" id="csvFileInput" accept=".csv" style="display: none;">
            <button id="importCsvBtn" class="btn btn-secondary">
              üìÑ Import CSV
            </button>
          </div>
        </div>
        <table class="led-table">
        <thead>
          <tr>
            <th>LED</th>
            <th>Airport</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="ledTableBody">
          <!-- Populated by JavaScript -->
        </tbody>
      </table>
      </div> <!-- /manualLedConfig -->
    </div>

    <!-- Save Button -->
    <button id="saveBtn" class="btn btn-primary btn-block">
      üíæ Save Configuration
    </button>
  </div>

  <script>
    // Global state
    let currentConfig = {
      numLeds: 80,
      brightness: 20,
      updateIntervalMinutes: 15,
      hostname: 'led-sectional',
      useMDNS: true,
      airports: []
    };
    // Fallback inline airport database (used if GitHub fetch fails)
    let airportsDatabase = [
      { code: "LIFR", name: "Low IFR (Legend)", city: "Flight Category" },
      { code: "IFR", name: "IFR (Legend)", city: "Flight Category" },
      { code: "MVFR", name: "Marginal VFR (Legend)", city: "Flight Category" },
      { code: "WVFR", name: "Windy VFR (Legend)", city: "Flight Category" },
      { code: "VFR", name: "VFR (Legend)", city: "Flight Category" },
      { code: "NULL", name: "Off (No Assignment)", city: "Special" },
      { code: "BLACK", name: "Off (Black)", city: "Special" }
    ];
    let statusData = [];

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', async function() {
      // Story 3.2: Show loading indicator during page initialization
      showLoadingIndicator('Loading configuration...');

      try {
        // Load airport database from GitHub
        await loadAirportDatabase();

        // Load current config
        await loadConfig();

        // Load status indicators
        await loadStatus();

        // Auto-refresh status every 60 seconds
        setInterval(loadStatus, 60000);

        // Setup event listeners
        setupEventListeners();

        // Check for crashed wizard session (do this AFTER config loads)
        setTimeout(() => checkForCrashedWizardSession(), 500);
      } finally {
        // Story 3.2: Hide loading indicator once everything is loaded
        hideLoadingIndicator();
      }
    });

    // Load airport database from ESP8266 LittleFS
    async function loadAirportDatabase() {
      try {
        const response = await fetch('/data/airports.json');
        if (!response.ok) {
          console.warn('Failed to load airport database from ESP8266, using fallback values only');
          return;
        }
        const airportsFromESP = await response.json();
        // Transform array format [code, name, state] to object format {code, name, city}
        // Note: "city" field is actually state abbreviation in current data format
        const transformedAirports = airportsFromESP.map(a => ({
          code: a[0],
          name: a[1],
          city: a[2]  // This is STATE, not city - but kept for compatibility
        }));
        // APPEND to existing fallback values, don't replace
        airportsDatabase = [...airportsDatabase, ...transformedAirports];
        console.log(`Loaded ${airportsDatabase.length} airports total from ESP8266`);
      } catch (error) {
        console.warn('Airport database unavailable from ESP8266, using fallback values:', error);
      }
    }

    // Load configuration from ESP8266
    async function loadConfig() {
      try {
        const response = await fetch('/config');
        if (!response.ok) throw new Error('Failed to load config');

        const data = await response.json();
        currentConfig = {
          numLeds: data.numLeds || 80,
          brightness: data.brightness || 20,
          updateIntervalMinutes: data.updateIntervalMinutes || 15,
          hostname: data.hostname || 'led-sectional',
          useMDNS: data.useMDNS !== false,
          airports: data.airports || []
        };

        // Populate form fields
        document.getElementById('numLeds').value = currentConfig.numLeds;
        document.getElementById('brightness').value = currentConfig.brightness;
        document.getElementById('brightnessValue').value = currentConfig.brightness;
        document.getElementById('updateInterval').value = currentConfig.updateIntervalMinutes;
        document.getElementById('hostname').value = currentConfig.hostname;
        document.getElementById('hostnamePreview').textContent = currentConfig.hostname;
        document.getElementById('useMDNS').checked = currentConfig.useMDNS;

        // Render LED table
        renderLEDTable();

      } catch (error) {
        showToast('Error loading configuration: ' + error.message, 'error');
      }
    }

    // Load LED status from ESP8266
    async function loadStatus() {
      try {
        const response = await fetch('/api/status');
        if (!response.ok) {
          console.warn('Status endpoint not available');
          return;
        }

        const data = await response.json();
        statusData = data.leds || [];  // Extract the "leds" array
        updateStatusIndicators();

      } catch (error) {
        console.warn('Failed to load status:', error);
      }
    }

    // Derive display color from flight category, not LED color
    function getColorFromFlightCategory(assignment, wxValue) {
      // LEGEND LEDs: Assignment IS the flight category (LIFR, IFR, etc.)
      // These can be at ANY LED index, not just 0-4
      const legendValues = ['LIFR', 'IFR', 'MVFR', 'WVFR', 'VFR'];
      if (legendValues.includes(assignment)) {
        switch(assignment) {
          case 'LIFR': return '#FF00FF';  // Magenta
          case 'IFR':  return '#FF0000';  // Red
          case 'MVFR': return '#0000FF';  // Blue
          case 'WVFR': return '#FFFF00';  // Yellow (windy VFR)
          case 'VFR':  return '#00FF00';  // Green
        }
      }

      // NULL/BLACK assignments
      if (assignment === 'NULL' || assignment === 'BLACK' || !wxValue) {
        return '#000000';  // Black
      }

      // AIRPORT LEDs: Color based on wxValue from weather cache
      switch(wxValue) {
        case 'LIFR': return '#FF00FF';  // Magenta
        case 'IFR':  return '#FF0000';  // Red
        case 'MVFR': return '#0000FF';  // Blue
        case 'WVFR': return '#FFFF00';  // Yellow (windy VFR)
        case 'VFR':  return '#00FF00';  // Green
        case 'Pending': return '#FFA500';  // Orange (no data yet)
        case '-':    return '#000000';  // Black (NULL/BLACK assignment)
        default:     return '#888888';  // Gray (unknown)
      }
    }

    // Render LED table with autocomplete inputs
    function renderLEDTable() {
      const tbody = document.getElementById('ledTableBody');
      tbody.innerHTML = '';

      for (let i = 0; i < currentConfig.numLeds; i++) {
        const assignment = currentConfig.airports[i] || 'NULL';
        const status = statusData.find(s => s.index === i) || { wxValue: null, color: '#000000' };

        const tr = document.createElement('tr');

        // LED number
        const tdNum = document.createElement('td');
        tdNum.className = 'led-number';
        tdNum.textContent = i;
        tr.appendChild(tdNum);

        // Airport code (editable with autocomplete)
        const tdAirport = document.createElement('td');
        tdAirport.innerHTML = `
          <div class="airport-input-wrapper">
            <input type="text" class="airport-input" data-led="${i}" value="${assignment}"
                   placeholder="Type to search..." autocapitalize="characters">
            <div class="autocomplete-dropdown" data-led="${i}"></div>
          </div>
        `;
        tr.appendChild(tdAirport);

        // Status dot - derive color from flight category, NOT LED color
        const tdStatus = document.createElement('td');
        const statusDot = document.createElement('span');
        statusDot.className = 'status-dot';
        statusDot.dataset.led = i;
        statusDot.style.backgroundColor = getColorFromFlightCategory(assignment, status.wxValue);
        tdStatus.appendChild(statusDot);
        tr.appendChild(tdStatus);

        tbody.appendChild(tr);
      }

      // Add autocomplete event listeners
      document.querySelectorAll('.airport-input').forEach(input => {
        input.addEventListener('input', handleAutocompleteInput);
        input.addEventListener('focus', handleAutocompleteInput);
        input.addEventListener('blur', (e) => {
          setTimeout(() => hideAutocomplete(e.target.dataset.led), 200);
        });
      });
    }

    // Update status indicators
    function updateStatusIndicators() {
      statusData.forEach(item => {
        const dot = document.querySelector(`.status-dot[data-led="${item.index}"]`);
        if (dot) {
          // Derive color from flight category, NOT LED color
          const assignment = currentConfig.airports[item.index] || 'NULL';
          dot.style.backgroundColor = getColorFromFlightCategory(assignment, item.wxValue);
        }
      });
    }

    // Handle autocomplete input
    function handleAutocompleteInput(e) {
      const input = e.target;
      const ledIndex = input.dataset.led;
      const query = input.value.trim().toUpperCase();

      // If empty, show all options (special values + some airports)
      let matches;
      if (query.length === 0) {
        matches = airportsDatabase.slice(0, 20);  // Show first 20 options
      } else {
        matches = searchAirports(query);
      }

      showAutocomplete(ledIndex, matches, input);
    }

    // Search airports
    function searchAirports(query) {
      const q = query.toLowerCase();

      // Filter from airportsDatabase (already includes special values + airports)
      const matches = airportsDatabase.filter(a =>
        a && a.code && a.name && a.city &&
        (a.code.toLowerCase().includes(q) ||
         a.name.toLowerCase().includes(q) ||
         a.city.toLowerCase().includes(q))
      );

      return matches.slice(0, 10);
    }

    // Show autocomplete dropdown
    function showAutocomplete(ledIndex, matches, inputEl) {
      const dropdown = document.querySelector(`.autocomplete-dropdown[data-led="${ledIndex}"]`);

      if (matches.length === 0) {
        dropdown.innerHTML = '<div class="autocomplete-no-results">No airports found</div>';
        dropdown.classList.add('show');
        return;
      }

      const query = inputEl.value.toUpperCase();
      dropdown.innerHTML = matches.map(a => {
        const displayName = a.name.length > 35 ? a.name.substring(0, 32) + '...' : a.name;
        return `<div class="autocomplete-item" onclick="selectAirport(${ledIndex}, '${a.code}')">
          <span class="autocomplete-code">${a.code}</span>
          <span class="autocomplete-name">${displayName}</span>
        </div>`;
      }).join('');

      dropdown.classList.add('show');
    }

    // Hide autocomplete dropdown
    function hideAutocomplete(ledIndex) {
      const dropdown = document.querySelector(`.autocomplete-dropdown[data-led="${ledIndex}"]`);
      if (dropdown) {
        dropdown.classList.remove('show');
      }
    }

    // Select airport from autocomplete
    function selectAirport(ledIndex, code) {
      currentConfig.airports[ledIndex] = code;
      const input = document.querySelector(`.airport-input[data-led="${ledIndex}"]`);
      if (input) {
        input.value = code;
      }

      // Also update wizard state if wizard is active
      if (wizardActive && wizardState.airports) {
        wizardState.airports[ledIndex] = code;
      }

      hideAutocomplete(ledIndex);
    }

    // Setup event listeners
    function setupEventListeners() {
      // Hostname preview
      document.getElementById('hostname').addEventListener('input', (e) => {
        document.getElementById('hostnamePreview').textContent = e.target.value || 'led-sectional';
      });

      // Brightness slider sync
      const brightnessSlider = document.getElementById('brightness');
      const brightnessValue = document.getElementById('brightnessValue');

      brightnessSlider.addEventListener('input', (e) => {
        brightnessValue.value = e.target.value;
      });

      brightnessValue.addEventListener('input', (e) => {
        let val = parseInt(e.target.value);
        if (isNaN(val)) val = 0;
        if (val < 0) val = 0;
        if (val > 255) val = 255;
        brightnessSlider.value = val;
        brightnessValue.value = val;
      });

      // Number of LEDs change
      document.getElementById('numLeds').addEventListener('change', (e) => {
        const newNum = parseInt(e.target.value);
        if (newNum >= 5 && newNum <= 150 && newNum !== currentConfig.numLeds) {
          currentConfig.numLeds = newNum;
          renderLEDTable();
        }
      });

      // Search box filtering
      document.getElementById('searchBox').addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase();
        const rows = document.querySelectorAll('#ledTableBody tr');

        rows.forEach(row => {
          const ledNum = row.querySelector('.led-number').textContent;
          const airportInput = row.querySelector('.airport-input');
          const airportCode = airportInput ? airportInput.value.toLowerCase() : '';

          if (ledNum.includes(query) || airportCode.includes(query)) {
            row.style.display = '';
          } else {
            row.style.display = 'none';
          }
        });
      });

      // Save button
      document.getElementById('saveBtn').addEventListener('click', saveConfiguration);

      // CSV import button
      document.getElementById('importCsvBtn').addEventListener('click', () => {
        document.getElementById('csvFileInput').click();
      });

      document.getElementById('csvFileInput').addEventListener('change', handleCSVImport);
    }

    // CSV Import Handler
    async function handleCSVImport(e) {
      const file = e.target.files[0];
      if (!file) return;

      // Reset file input for next import
      e.target.value = '';

      if (!file.name.endsWith('.csv')) {
        showToast('Please select a CSV file', 'error');
        return;
      }

      try {
        const text = await file.text();
        const lines = text.split(/\r?\n/).filter(line => line.trim());

        if (lines.length === 0) {
          showToast('CSV file is empty', 'error');
          return;
        }

        let imported = 0;
        let errors = [];
        const newAirports = [...currentConfig.airports]; // Clone existing array

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;

          // Parse CSV line (simple comma split - handles most cases)
          const parts = line.split(',').map(p => p.trim());

          if (parts.length < 2) {
            errors.push(`Line ${i+1}: Invalid format (need index,code)`);
            continue;
          }

          const index = parseInt(parts[0]);
          const code = parts[1].toUpperCase();

          // Validation
          if (isNaN(index)) {
            errors.push(`Line ${i+1}: Invalid index "${parts[0]}"`);
            continue;
          }

          if (index < 0 || index >= 150) {
            errors.push(`Line ${i+1}: Index ${index} out of range (0-149)`);
            continue;
          }

          // Validate airport code format
          if (!/^([A-Z0-9]{4}|NULL|BLACK|LIFR|IFR|MVFR|WVFR|VFR)$/.test(code)) {
            errors.push(`Line ${i+1}: Invalid code "${code}"`);
            continue;
          }

          newAirports[index] = code;
          imported++;
        }

        // Only apply if at least one import succeeded
        if (imported === 0) {
          showToast('No valid entries found in CSV', 'error');
          if (errors.length > 0) {
            console.error('CSV Import Errors:', errors);
            showToast(`Errors: ${errors.slice(0, 3).join(', ')}`, 'error', 8000);
          }
          return;
        }

        // Update LED count to highest index + 1
        const highestIndex = Math.max(...newAirports.map((code, idx) =>
          (code && code !== 'NULL') ? idx : -1
        ));
        const newNumLeds = Math.max(highestIndex + 1, currentConfig.numLeds);

        // Update config
        currentConfig.airports = newAirports;
        currentConfig.numLeds = newNumLeds;
        document.getElementById('numLeds').value = newNumLeds;

        // Re-render table
        renderLEDTable();

        // Show success/warning message
        if (errors.length > 0) {
          showToast(`Imported ${imported} LEDs with ${errors.length} errors (check console)`, 'warning', 8000);
          console.error('CSV Import Errors:', errors);
        } else {
          showToast(`Successfully imported ${imported} LED assignments`, 'success');
        }

      } catch (error) {
        console.error('CSV import error:', error);
        showToast(`Failed to import CSV: ${error.message}`, 'error');
      }
    }

    // Save configuration
    async function saveConfiguration() {
      const saveBtn = document.getElementById('saveBtn');

      // Gather form data
      const numLeds = parseInt(document.getElementById('numLeds').value);
      const brightness = parseInt(document.getElementById('brightness').value);
      const updateIntervalMinutes = parseInt(document.getElementById('updateInterval').value);
      const hostname = document.getElementById('hostname').value.trim() || 'led-sectional';
      const useMDNS = document.getElementById('useMDNS').checked;

      // Validation
      if (numLeds < 1 || numLeds > 150) {
        showToast('Number of LEDs must be between 1 and 150', 'error');
        return;
      }

      if (brightness < 0 || brightness > 255) {
        showToast('Brightness must be between 0 and 255', 'error');
        return;
      }

      if (updateIntervalMinutes < 5 || updateIntervalMinutes > 60) {
        showToast('Update interval must be between 5 and 60 minutes', 'error');
        return;
      }

      // Hostname validation
      if (!/^[a-zA-Z0-9-]+$/.test(hostname)) {
        showToast('Hostname can only contain letters, numbers, and hyphens', 'error');
        return;
      }

      if (hostname.length > 32) {
        showToast('Hostname must be 32 characters or less', 'error');
        return;
      }

      if (hostname.startsWith('-') || hostname.endsWith('-')) {
        showToast('Hostname cannot start or end with a hyphen', 'error');
        return;
      }

      // Gather airport assignments
      const airports = [];
      for (let i = 0; i < numLeds; i++) {
        const input = document.querySelector(`.airport-input[data-led="${i}"]`);
        airports.push(input ? input.value.toUpperCase() : 'NULL');
      }

      const config = {
        numLeds,
        brightness,
        updateIntervalMinutes,
        hostname,
        useMDNS,
        airports
      };

      // Story 3.2: Show loading indicator
      showLoadingIndicator('Saving configuration...');

      try {
        const response = await fetch('/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(config)
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(errorText || 'Failed to save configuration');
        }

        // Check for hostname change warning
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
          const data = await response.json();
          if (data.hostnameChanged) {
            hideLoadingIndicator();
            showToast('‚ö†Ô∏è ' + data.message + ' New URL: http://' + hostname + '.local', 'warning', 8000);
          } else {
            hideLoadingIndicator();
            showToast('Configuration saved successfully!', 'success');
          }
        } else {
          hideLoadingIndicator();
          showToast('Configuration saved successfully!', 'success');
        }

        // Update current config
        currentConfig = config;

        // CRITICAL: Force weather update after saving config
        // Otherwise new airport assignments show as "Pending" until next 15-minute cycle
        showLoadingIndicator('Updating weather data...');
        try {
          const refreshResponse = await fetch('/api/forceRefresh', { method: 'POST' });
          hideLoadingIndicator();
          if (refreshResponse.ok) {
            showToast('Weather data updated successfully!', 'success');
            // Reload status to show updated colors
            await loadStatus();
          } else {
            console.warn('Force refresh failed, weather will update on next cycle');
          }
        } catch (refreshError) {
          hideLoadingIndicator();
          console.warn('Force refresh error:', refreshError);
        }

      } catch (error) {
        hideLoadingIndicator();
        showToast('Error saving configuration: ' + error.message, 'error');
      }
    }

    // Show toast notification (simple implementation without component library)
    function showToast(message, type = 'info', duration = 8000) {
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 16px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        max-width: 300px;
        z-index: 10000;
        background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : type === 'warning' ? '#ffc107' : '#0066cc'};
        color: white;
        font-size: 14px;
        cursor: pointer;
      `;

      // Click to dismiss
      toast.addEventListener('click', () => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      });

      document.body.appendChild(toast);

      // Auto-dismiss after duration
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, duration);
    }

    // ====================================================================
    // LED SETUP WIZARD FUNCTIONALITY
    // ====================================================================

    // Wizard state
    let wizardActive = false;
    let wizardState = {
      numLeds: 0,
      currentIndex: 0,
      airports: [],
      brightness: 20
    };

    // Cache for config when modal opens
    let cachedConfigForWizard = null;

    // ====================================================================
    // WIZARD CRASH RECOVERY - localStorage Auto-Save
    // ====================================================================
    const WIZARD_STATE_KEY = 'skyboard_wizard_state';
    const WIZARD_STATE_TIMESTAMP_KEY = 'skyboard_wizard_timestamp';

    /**
     * Save wizard state to localStorage (called after every change)
     */
    function saveWizardStateToLocalStorage() {
      if (!wizardActive) return;

      try {
        const stateToSave = {
          numLeds: wizardState.numLeds,
          currentIndex: wizardState.currentIndex,
          airports: wizardState.airports,
          brightness: wizardState.brightness
        };
        localStorage.setItem(WIZARD_STATE_KEY, JSON.stringify(stateToSave));
        localStorage.setItem(WIZARD_STATE_TIMESTAMP_KEY, Date.now().toString());
        console.log('[Wizard] State auto-saved to localStorage:', stateToSave);
      } catch (error) {
        console.error('[Wizard] Failed to save state to localStorage:', error);
      }
    }

    /**
     * Load wizard state from localStorage (called on page load if crash detected)
     */
    function loadWizardStateFromLocalStorage() {
      try {
        const savedState = localStorage.getItem(WIZARD_STATE_KEY);
        const savedTimestamp = localStorage.getItem(WIZARD_STATE_TIMESTAMP_KEY);

        if (!savedState || !savedTimestamp) return null;

        const age = Date.now() - parseInt(savedTimestamp);
        const MAX_AGE = 24 * 60 * 60 * 1000; // 24 hours

        if (age > MAX_AGE) {
          console.log('[Wizard] Saved state too old, discarding');
          clearWizardStateFromLocalStorage();
          return null;
        }

        const state = JSON.parse(savedState);
        console.log('[Wizard] Recovered state from localStorage:', state);
        return state;
      } catch (error) {
        console.error('[Wizard] Failed to load state from localStorage:', error);
        return null;
      }
    }

    /**
     * Clear wizard state from localStorage
     */
    function clearWizardStateFromLocalStorage() {
      localStorage.removeItem(WIZARD_STATE_KEY);
      localStorage.removeItem(WIZARD_STATE_TIMESTAMP_KEY);
      console.log('[Wizard] Cleared saved state from localStorage');
    }

    /**
     * Check for crashed wizard session on page load
     */
    function checkForCrashedWizardSession() {
      const savedState = loadWizardStateFromLocalStorage();

      if (savedState && savedState.numLeds > 0) {
        // Show recovery modal
        const modal = new Modal();
        const modalContent = document.createElement('div');
        modalContent.innerHTML = `
          <p><strong>üîß Wizard Session Recovery</strong></p>
          <p>We detected an incomplete wizard session with <strong>${savedState.numLeds} LED${savedState.numLeds > 1 ? 's' : ''}</strong> configured.</p>
          <p>Would you like to recover your progress?</p>
          <div style="display: flex; gap: 12px; margin-top: 24px;">
            <button id="recoveryDiscardBtn" class="btn btn-secondary" style="flex: 1;">Discard</button>
            <button id="recoveryRecoverBtn" class="btn btn-primary" style="flex: 1;">‚úì Recover</button>
          </div>
        `;

        modal.show('Recover Wizard Session', modalContent);

        document.getElementById('recoveryDiscardBtn').onclick = () => {
          clearWizardStateFromLocalStorage();
          modal.hide();
          showToast('Wizard session discarded', 'info');
        };

        document.getElementById('recoveryRecoverBtn').onclick = async () => {
          modal.hide();
          await recoverWizardSession(savedState);
        };
      }
    }

    /**
     * Recover wizard session from saved state
     */
    async function recoverWizardSession(savedState) {
      try {
        // First, try to reset ESP8266 setup state
        showToast('Recovering wizard session...', 'info', 2000);

        // Call /setup/start to reset ESP8266 state (it might be stuck)
        const brightness = parseInt(document.getElementById('brightness').value) || savedState.brightness || 20;
        const response = await fetch('/setup/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            brightness: brightness,
            airports: savedState.airports.slice(0, savedState.numLeds)
          })
        });

        if (!response.ok) {
          throw new Error('Failed to restart setup mode');
        }

        // Restore wizard state
        wizardActive = true;
        wizardState = {
          numLeds: savedState.numLeds,
          currentIndex: savedState.currentIndex,
          airports: savedState.airports,
          brightness: savedState.brightness
        };

        // Show wizard UI
        document.getElementById('manualLedConfig').style.display = 'none';
        document.getElementById('wizardContainer').style.display = 'block';
        document.getElementById('startWizardBtn').style.display = 'none';
        document.getElementById('saveBtn').style.display = 'none';

        // Render wizard rows
        renderWizardRows();

        // Focus last input
        const lastInput = document.getElementById(`wizard-input-${wizardState.currentIndex}`);
        if (lastInput) {
          lastInput.focus();
        }

        showToast(`‚úì Recovered ${savedState.numLeds} LED${savedState.numLeds > 1 ? 's' : ''}! Continue where you left off.`, 'success', 5000);
      } catch (error) {
        console.error('[Wizard] Recovery failed:', error);
        showToast('Recovery failed. Starting fresh wizard session.', 'error');
        clearWizardStateFromLocalStorage();
      }
    }

    /**
     * Show wizard start modal
     */
    function showWizardStartModal(numLeds) {
      const modal = document.getElementById('wizardStartModal');
      const ledCountText = document.getElementById('wizardModalLedCount');
      const continueLedCount = document.getElementById('wizardContinueLedCount');

      // Update LED count displays
      ledCountText.innerHTML = `You currently have <strong>${numLeds} LED${numLeds !== 1 ? 's' : ''}</strong> configured.`;
      continueLedCount.textContent = numLeds;

      modal.style.display = 'flex';
    }

    /**
     * Hide wizard start modal
     */
    function hideWizardStartModal() {
      const modal = document.getElementById('wizardStartModal');
      modal.style.display = 'none';
    }

    /**
     * Start the LED setup wizard
     */
    async function startWizard(continueFromExisting = false) {
      try {
        // Build request body
        const brightness = parseInt(document.getElementById('brightness').value) || 20;
        let requestBody = {
          brightness: brightness
        };

        // If continuing from existing, add airports array
        if (continueFromExisting && cachedConfigForWizard) {
          // Extract existing airports (only up to numLeds)
          const existingAirports = cachedConfigForWizard.airports.slice(0, cachedConfigForWizard.numLeds);

          // Validate airports array length (max 150 LEDs)
          if (existingAirports.length > 150) {
            showToast('Cannot start wizard: too many LEDs (max 150)', 'error');
            return;
          }

          requestBody.airports = existingAirports;
        }

        // Call backend to enter setup mode
        const response = await fetch('/setup/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          throw new Error('Failed to start setup mode');
        }

        const result = await response.json();

        // Initialize wizard state based on mode
        wizardActive = true;
        if (continueFromExisting && cachedConfigForWizard) {
          // Continue mode: Pre-fill with existing airports + empty slot for next LED
          wizardState = {
            numLeds: cachedConfigForWizard.numLeds + 1,
            currentIndex: cachedConfigForWizard.numLeds,
            airports: [...cachedConfigForWizard.airports.slice(0, cachedConfigForWizard.numLeds), ''],
            brightness: brightness
          };
        } else {
          // Start from scratch: Empty config
          wizardState = {
            numLeds: 1,
            currentIndex: 0,
            airports: [''],
            brightness: brightness
          };
        }

        // CRITICAL: Save initial state to localStorage
        saveWizardStateToLocalStorage();

        // Hide manual config, show wizard
        document.getElementById('manualLedConfig').style.display = 'none';
        document.getElementById('wizardContainer').style.display = 'block';
        document.getElementById('startWizardBtn').style.display = 'none';
        document.getElementById('saveBtn').style.display = 'none'; // Hide manual save button

        // Render wizard rows
        renderWizardRows();

        // Show appropriate success message
        if (continueFromExisting) {
          showToast(`Wizard started! Continuing from ${cachedConfigForWizard.numLeds} LEDs. LED ${cachedConfigForWizard.numLeds} is blinking orange.`, 'success');
        } else {
          showToast('Wizard started! LED 0 is blinking orange.', 'success');
        }
      } catch (error) {
        console.error('Failed to start wizard:', error);
        showToast('Failed to start wizard. Check ESP8266 connection.', 'error');
      }
    }

    /**
     * Render all wizard rows based on current state
     */
    function renderWizardRows() {
      const container = document.getElementById('wizardRows');
      container.innerHTML = '';

      // Render all existing LED rows
      for (let i = 0; i < wizardState.numLeds; i++) {
        const row = createWizardRow(i);
        container.appendChild(row);
      }
    }

    /**
     * Create a single wizard row for an LED
     */
    function createWizardRow(ledIndex) {
      const row = document.createElement('div');
      row.className = 'wizard-row';
      row.id = `wizard-row-${ledIndex}`;

      // LED label
      const label = document.createElement('span');
      label.className = 'wizard-led-label';
      label.textContent = `LED ${ledIndex}`;

      // Airport input with autocomplete wrapper
      const inputWrapper = document.createElement('div');
      inputWrapper.className = 'airport-input-wrapper';

      const input = document.createElement('input');
      input.type = 'text';
      input.id = `wizard-input-${ledIndex}`;
      input.className = 'wizard-input airport-input';
      input.dataset.led = ledIndex;
      input.placeholder = 'Type to search...';
      input.value = wizardState.airports[ledIndex] || '';
      input.autocomplete = 'off';
      input.autocapitalize = 'characters';

      // Autocomplete dropdown
      const dropdown = document.createElement('div');
      dropdown.className = 'autocomplete-dropdown';
      dropdown.dataset.led = ledIndex;

      inputWrapper.appendChild(input);
      inputWrapper.appendChild(dropdown);

      // Update state on input change
      input.addEventListener('input', (e) => {
        wizardState.airports[ledIndex] = e.target.value.trim().toUpperCase();
        handleAutocompleteInput(e);
        // Auto-save after every keystroke
        saveWizardStateToLocalStorage();
      });

      // Autocomplete focus/blur handlers
      input.addEventListener('focus', handleAutocompleteInput);
      input.addEventListener('blur', (e) => {
        setTimeout(() => hideAutocomplete(ledIndex), 200);
      });

      // Next button (only on the last LED)
      const nextBtn = document.createElement('button');
      nextBtn.className = 'wizard-next-btn';
      nextBtn.textContent = 'Next';
      nextBtn.dataset.led = ledIndex;

      // Only enable Next button on the last LED
      if (ledIndex !== wizardState.numLeds - 1) {
        nextBtn.disabled = true;
        nextBtn.style.opacity = '0.3';
        nextBtn.textContent = '‚úì';
      } else {
        nextBtn.addEventListener('click', () => handleWizardNext(ledIndex));
      }

      row.appendChild(label);
      row.appendChild(inputWrapper);
      row.appendChild(nextBtn);

      return row;
    }

    /**
     * Handle clicking "Next" to add another LED
     */
    async function handleWizardNext(ledIndex) {
      const input = document.getElementById(`wizard-input-${ledIndex}`);
      const value = input.value.trim().toUpperCase();

      // Validate input
      if (!value) {
        showToast('Please enter an airport code or "NULL"', 'error');
        input.focus();
        return;
      }

      // Validate ICAO format (4 alphanumeric characters) or special values
      if (!/^([A-Z0-9]{4}|NULL|BLACK)$/.test(value)) {
        showToast('Invalid airport code. Use 4-character ICAO code (e.g., K1B9) or "NULL".', 'error', 8000);
        input.focus();
        return;
      }

      try {
        // Update state
        wizardState.airports[ledIndex] = value;
        wizardState.numLeds += 1;
        wizardState.currentIndex = wizardState.numLeds - 1;
        wizardState.airports[wizardState.currentIndex] = ''; // New empty slot

        // CRITICAL: Save to localStorage BEFORE network call
        saveWizardStateToLocalStorage();

        // Send update to backend
        const response = await fetch('/setup/update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(wizardState)
        });

        if (!response.ok) {
          throw new Error('Failed to update setup state');
        }

        // Re-render rows to add new one
        renderWizardRows();

        // Focus new input
        const newInput = document.getElementById(`wizard-input-${wizardState.currentIndex}`);
        if (newInput) {
          newInput.focus();
        }

        showToast(`LED ${ledIndex} configured. LED ${wizardState.currentIndex} is now blinking.`, 'success');
      } catch (error) {
        console.error('Failed to add next LED:', error);
        showToast('Failed to update. Check ESP8266 connection.', 'error');

        // Revert state
        wizardState.numLeds -= 1;
        wizardState.currentIndex = wizardState.numLeds - 1;
        wizardState.airports.pop();
        // Re-save reverted state
        saveWizardStateToLocalStorage();
      }
    }

    /**
     * Handle clicking "Save Configuration"
     */
    async function handleWizardSave() {
      // Validate last LED has a value
      const lastIndex = wizardState.numLeds - 1;
      const lastInput = document.getElementById(`wizard-input-${lastIndex}`);
      const lastValue = lastInput ? lastInput.value.trim().toUpperCase() : '';

      if (!lastValue) {
        showToast(`Please fill in LED ${lastIndex} or remove it before saving.`, 'error');
        lastInput.focus();
        return;
      }

      // Validate ICAO format
      if (!/^([A-Z0-9]{4}|NULL|BLACK)$/.test(lastValue)) {
        showToast('Invalid airport code on last LED. Use 4-character ICAO code (e.g., K1B9) or "NULL".', 'error', 8000);
        lastInput.focus();
        return;
      }

      // Update last value in state
      wizardState.airports[lastIndex] = lastValue;

      // Show confirmation modal
      const modal = new Modal();
      const modalContent = document.createElement('div');
      modalContent.innerHTML = `
        <p>Are you sure you want to save this configuration?</p>
        <p style="margin-top: 16px;"><strong>You have configured ${wizardState.numLeds} LED${wizardState.numLeds > 1 ? 's' : ''}.</strong></p>
        <div style="display: flex; gap: 12px; margin-top: 24px;">
          <button id="modalCancelBtn" class="btn btn-secondary" style="flex: 1;">No, Continue</button>
          <button id="modalConfirmBtn" class="btn btn-success" style="flex: 1;">Yes, Save</button>
        </div>
      `;

      modal.show('Confirm Save', modalContent);

      // Attach button handlers
      document.getElementById('modalCancelBtn').onclick = () => modal.hide();
      document.getElementById('modalConfirmBtn').onclick = async () => {
        modal.hide();
        await saveWizardConfig();
      };
    }

    /**
     * Save wizard configuration and exit wizard mode
     */
    async function saveWizardConfig() {
      try {
        // Build full config object (150 airports, filled with NULL)
        const fullAirports = new Array(150).fill('NULL');
        for (let i = 0; i < wizardState.numLeds; i++) {
          fullAirports[i] = wizardState.airports[i] || 'NULL';
        }

        const finalConfig = {
          numLeds: wizardState.numLeds,
          airports: fullAirports,
          brightness: wizardState.brightness,
          hostname: document.getElementById('hostname').value.trim(),
          useMDNS: document.getElementById('useMDNS').checked,
          updateIntervalMinutes: parseInt(document.getElementById('updateInterval').value)
        };

        // Send to backend
        const response = await fetch('/setup/finish', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(finalConfig)
        });

        if (!response.ok) {
          throw new Error('Failed to save configuration');
        }

        showToast(`Configuration saved! ${wizardState.numLeds} LEDs configured.`, 'success', 5000);

        // CRITICAL: Clear localStorage since wizard completed successfully
        clearWizardStateFromLocalStorage();

        // Exit wizard mode
        exitWizard();

        // Reload config to update UI
        setTimeout(() => {
          loadConfig();
        }, 1000);
      } catch (error) {
        console.error('Failed to save wizard config:', error);
        showToast('Failed to save configuration. Check ESP8266 connection.', 'error');
      }
    }

    /**
     * Exit wizard mode and restore manual config UI
     */
    function exitWizard() {
      wizardActive = false;
      wizardState = {
        numLeds: 0,
        currentIndex: 0,
        airports: [],
        brightness: 20
      };

      // Clear localStorage (wizard is over)
      clearWizardStateFromLocalStorage();

      // Hide wizard, show manual config
      document.getElementById('wizardContainer').style.display = 'none';
      document.getElementById('manualLedConfig').style.display = 'block';
      document.getElementById('startWizardBtn').style.display = 'inline-block';
      document.getElementById('saveBtn').style.display = 'block'; // Show manual save button

      // Clear wizard rows
      document.getElementById('wizardRows').innerHTML = '';
    }

    /**
     * Warn user if navigating away during wizard
     */
    window.addEventListener('beforeunload', (e) => {
      if (wizardActive) {
        e.preventDefault();
        e.returnValue = 'You have an active wizard session. Progress will be lost if you leave.';
        return e.returnValue;
      }
    });

    // Attach wizard button event listeners after DOM loads
    document.addEventListener('DOMContentLoaded', () => {
      const startBtn = document.getElementById('startWizardBtn');
      if (startBtn) {
        startBtn.addEventListener('click', async () => {
          try {
            // Fetch current config to populate modal
            const response = await fetch('/config');
            if (!response.ok) {
              throw new Error('Failed to fetch config');
            }
            cachedConfigForWizard = await response.json();

            // Show modal with current LED count
            showWizardStartModal(cachedConfigForWizard.numLeds);
          } catch (error) {
            console.error('Failed to load current config:', error);
            showToast('Failed to load current config. Check ESP8266 connection.', 'error');
          }
        });
      }

      // Wire up modal buttons
      const startScratchBtn = document.getElementById('wizardStartScratchBtn');
      if (startScratchBtn) {
        startScratchBtn.addEventListener('click', () => {
          hideWizardStartModal();
          startWizard(false); // Start from scratch
        });
      }

      const continueBtn = document.getElementById('wizardContinueBtn');
      if (continueBtn) {
        continueBtn.addEventListener('click', () => {
          hideWizardStartModal();
          startWizard(true); // Continue from existing
        });
      }

      const cancelBtn = document.getElementById('wizardCancelBtn');
      if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
          hideWizardStartModal();
        });
      }

      // Close modal on backdrop click
      const modal = document.getElementById('wizardStartModal');
      if (modal) {
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            hideWizardStartModal();
          }
        });
      }

      // Close modal on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const modal = document.getElementById('wizardStartModal');
          if (modal && modal.style.display === 'flex') {
            hideWizardStartModal();
          }
        }
      });

      const saveBtn = document.getElementById('wizardSaveBtn');
      if (saveBtn) {
        saveBtn.addEventListener('click', handleWizardSave);
      }
    });

    // Story 3.2: Global error handler to prevent stuck loading states
    window.addEventListener('error', (event) => {
      console.error('Global error caught:', event.error);
      hideLoadingIndicator();
    });

    window.addEventListener('unhandledrejection', (event) => {
      console.error('Unhandled promise rejection:', event.reason);
      hideLoadingIndicator();
    });

  </script>

  <!-- Wizard Start Modal -->
  <div id="wizardStartModal" class="modal-overlay" style="display: none;">
    <div class="modal-box">
      <h2>Start LED Setup Wizard</h2>
      <p id="wizardModalLedCount" class="wizard-modal-description">
        You currently have <strong>0 LEDs</strong> configured.
      </p>
      <div class="wizard-modal-buttons">
        <button id="wizardStartScratchBtn" class="btn btn-secondary">
          Start from Scratch
        </button>
        <button id="wizardContinueBtn" class="btn btn-primary">
          Continue from Existing (<span id="wizardContinueLedCount">0</span> LEDs)
        </button>
        <button id="wizardCancelBtn" class="btn btn-ghost">
          Cancel
        </button>
      </div>
    </div>
  </div>

</body>
</html>
